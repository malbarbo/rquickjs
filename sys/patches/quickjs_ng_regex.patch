diff --git a/libregexp.c b/libregexp.c
index a2d56a7..18781ab 100644
--- a/libregexp.c
+++ b/libregexp.c
@@ -61,6 +61,7 @@ typedef enum {
 
 #define TMP_BUF_SIZE 128
 
+// invariant: is_unicode ^ unicode_sets (or neither, but not both)
 typedef struct {
     DynBuf byte_code;
     const uint8_t *buf_ptr;
@@ -68,6 +69,7 @@ typedef struct {
     const uint8_t *buf_start;
     int re_flags;
     BOOL is_unicode;
+    BOOL unicode_sets;
     BOOL ignore_case;
     BOOL dotall;
     int capture_count;
@@ -704,6 +706,9 @@ static int get_class_atom(REParseState *s, CharRange *cr,
                     /* always valid to escape these characters */
                     goto normal_char;
                 } else if (s->is_unicode) {
+                    // special case: allowed inside [] but not outside
+                    if (ret == -2 && *p == '-' && inclass)
+                        goto normal_char;
                 invalid_escape:
                     return re_parse_error(s, "invalid escape sequence in regular expression");
                 } else {
@@ -788,6 +793,25 @@ static int re_parse_char_class(REParseState *s, const uint8_t **pp)
     p = *pp;
     p++;    /* skip '[' */
 
+    if (s->unicode_sets) {
+        static const char verboten[] =
+            "()[{}/-|"                              "\0"
+            "&&!!##$$%%**++,,..::;;<<==>>??@@``~~"  "\0"
+            "^^^_^^";
+        const char *s = verboten;
+        int n = 1;
+        do {
+            if (!memcmp(s, p, n))
+                if (p[n] == ']')
+                    goto invalid_class_range;
+            s += n;
+            if (!*s) {
+                s++;
+                n++;
+            }
+        } while (n < 4);
+    }
+
     invert = FALSE;
     if (*p == '^') {
         p++;
@@ -800,6 +824,11 @@ static int re_parse_char_class(REParseState *s, const uint8_t **pp)
         c1 = get_class_atom(s, cr1, &p, TRUE);
         if ((int)c1 < 0)
             goto fail;
+        if (*p == '-' && p[1] == ']' && s->unicode_sets) {
+            if (c1 >= CLASS_RANGE_BASE)
+                cr_free(cr1);
+            goto invalid_class_range;
+        }
         if (*p == '-' && p[1] != ']') {
             const uint8_t *p0 = p + 1;
             if (c1 >= CLASS_RANGE_BASE) {
@@ -1734,6 +1763,7 @@ uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
     is_sticky = ((re_flags & LRE_FLAG_STICKY) != 0);
     s->ignore_case = ((re_flags & LRE_FLAG_IGNORECASE) != 0);
     s->dotall = ((re_flags & LRE_FLAG_DOTALL) != 0);
+    s->unicode_sets = ((re_flags & LRE_FLAG_UNICODE_SETS) != 0);
     s->capture_count = 1;
     s->total_capture_count = -1;
     s->has_named_captures = -1;
diff --git a/libregexp.h b/libregexp.h
index 7af7ece..0a49e72 100644
--- a/libregexp.h
+++ b/libregexp.h
@@ -35,6 +35,7 @@
 #define LRE_FLAG_STICKY     (1 << 5)
 #define LRE_FLAG_INDICES    (1 << 6) /* Unused by libregexp, just recorded. */
 #define LRE_FLAG_NAMED_GROUPS (1 << 7) /* named groups are present in the regexp */
+#define LRE_FLAG_UNICODE_SETS (1 << 8)
 
 uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
                      const char *buf, size_t buf_len, int re_flags,
